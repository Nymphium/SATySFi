@require: pervasives
@require: list
@require: gr

module Math
% :> sig
%
%   val \math : [math] inline-cmd
%   val +math : [inline-text?; math] block-cmd
%   val \eqn : [inline-text?; math] inline-cmd
%   val +math-list : [math list] block-cmd
%   val \math-list : [math list] inline-cmd
%   val +align : [(math list) list] block-cmd
%   val \align : [(math list) list] inline-cmd
%   val \text : [inline-text] math-cmd
%   val \frac : [math; math] math-cmd
%   val \sqrt : [math] math-cmd
%   val \lower : [math; math] math-cmd
%   val \upper : [math; math] math-cmd
%   val \math-skip : [length] math-cmd
%   val \math-color : [color; math] math-cmd
%   val join : math -> math list -> math
%   val half-length : length -> length -> length -> length -> length
%
%   val \mathord : [math] math-cmd
%   val \mathbin : [math] math-cmd
%   val \mathrel : [math] math-cmd
%   val \mathop : [math] math-cmd
%   val \mathprefix : [math] math-cmd
%   val \mathpunct : [math] math-cmd
%
%   val \math-style : [math-char-class; math] math-cmd
%   val \mathrm : [math] math-cmd
%   val \mathbf : [math] math-cmd
%   val \mathcal : [math] math-cmd
%   val \mathfrak : [math] math-cmd
%   val \mathbb : [math] math-cmd
%   val \bm : [math] math-cmd
%
%   val \math-style-token : [math-char-class; string] math-cmd
%   val \mathit-token : [string] math-cmd
%   val \mathrm-token : [string] math-cmd
%   val \mathbf-token : [string] math-cmd
%
%   val \alpha   : [] math-cmd
%   val \beta    : [] math-cmd
%   val \gamma   : [] math-cmd
%   val \delta   : [] math-cmd
%   val \epsilon : [] math-cmd
%   val \zeta    : [] math-cmd
%   val \eta     : [] math-cmd
%   val \theta   : [] math-cmd
%   val \iota    : [] math-cmd
%   val \kappa   : [] math-cmd
%   val \lambda  : [] math-cmd
%   val \mu      : [] math-cmd
%   val \nu      : [] math-cmd
%   val \xi      : [] math-cmd
%   val \omicron : [] math-cmd
%   val \pi      : [] math-cmd
%   val \rho     : [] math-cmd
%   val \sigma   : [] math-cmd
%   val \tau     : [] math-cmd
%   val \upsilon : [] math-cmd
%   val \phi     : [] math-cmd
%   val \chi     : [] math-cmd
%   val \psi     : [] math-cmd
%   val \omega   : [] math-cmd
%
%   val \Alpha   : [] math-cmd
%   val \Beta    : [] math-cmd
%   val \Gamma   : [] math-cmd
%   val \Delta   : [] math-cmd
%   val \Epsilon : [] math-cmd
%   val \Zeta    : [] math-cmd
%   val \Eta     : [] math-cmd
%   val \Theta   : [] math-cmd
%   val \Iota    : [] math-cmd
%   val \Kappa   : [] math-cmd
%   val \Lambda  : [] math-cmd
%   val \Mu      : [] math-cmd
%   val \Nu      : [] math-cmd
%   val \Xi      : [] math-cmd
%   val \Omicron : [] math-cmd
%   val \Pi      : [] math-cmd
%   val \Rho     : [] math-cmd
%   val \Sigma   : [] math-cmd
%   val \Tau     : [] math-cmd
%   val \Upsilon : [] math-cmd
%   val \Phi     : [] math-cmd
%   val \Chi     : [] math-cmd
%   val \Psi     : [] math-cmd
%   val \Omega   : [] math-cmd
%
%   val \to : [] math-cmd
%   val \pm : [] math-cmd
%   val \mp : [] math-cmd
%   val \times : [] math-cmd
%   val \setminus : [] math-cmd
%   val \ast : [] math-cmd
%   val \circ : [] math-cmd
%   val \bullet : [] math-cmd
%   val \cap : [] math-cmd
%   val \cup : [] math-cmd
%   val \uplus : [] math-cmd
%   val \sqcap : [] math-cmd
%   val \sqcup : [] math-cmd
%   val \wedge : [] math-cmd
%   val \vee : [] math-cmd
%   val \oplus : [] math-cmd
%   val \ominus : [] math-cmd
%   val \otimes : [] math-cmd
%   val \oslash : [] math-cmd
%
%   val \vdash : [] math-cmd
%   val \nvdash : [] math-cmd
%   val \dashv : [] math-cmd
%   val \vDash : [] math-cmd
%   val \nvDash : [] math-cmd
%   val \Vdash : [] math-cmd
%   val \nVdash : [] math-cmd
%
%   val \colon-rel : [] math-cmd
%
%   val \leq : [] math-cmd
%   val \geq : [] math-cmd
%   val \equiv : [] math-cmd
%   val \nequiv : [] math-cmd
%   val \neq : [] math-cmd
%   val \sim : [] math-cmd
%   val \nsim : [] math-cmd
%   val \simeq : [] math-cmd
%   val \nsimeq : [] math-cmd
%   val \propto : [] math-cmd
%   val \coloneq : [] math-cmd
%   val \eqcolon : [] math-cmd
%
%   val \in : [] math-cmd
%   val \nin : [] math-cmd
%   val \ni : [] math-cmd
%   val \nni : [] math-cmd
%   val \subset : [] math-cmd
%   val \supset : [] math-cmd
%   val \nsubset : [] math-cmd
%   val \nsupset : [] math-cmd
%   val \subseteq : [] math-cmd
%   val \supseteq : [] math-cmd
%   val \nsubseteq : [] math-cmd
%   val \nsupseteq : [] math-cmd
%   val \subsetneq : [] math-cmd
%   val \supsetneq : [] math-cmd
%   val \sqsubset : [] math-cmd
%   val \sqsupset : [] math-cmd
%   val \sqsubseteq : [] math-cmd
%   val \sqsupseteq : [] math-cmd
%   val \nsqsubseteq : [] math-cmd
%   val \nsqsupseteq : [] math-cmd
%   val \sqsubsetneq : [] math-cmd
%   val \sqsupsetneq : [] math-cmd
%   val \prec : [] math-cmd
%   val \succ : [] math-cmd
%   val \nprec : [] math-cmd
%   val \nsucc : [] math-cmd
%   val \preccurlyeq : [] math-cmd
%   val \succcurlyeq : [] math-cmd
%   val \precsim : [] math-cmd
%   val \succsim : [] math-cmd
%   val \npreccurlyeq : [] math-cmd
%   val \nsucccurlyeq : [] math-cmd
%
%   val \emptyset : [] math-cmd
%   val \infty : [] math-cmd
%   val \top : [] math-cmd
%   val \bot : [] math-cmd
%   val \therefore : [] math-cmd
%   val \because : [] math-cmd
%   val \forall : [] math-cmd
%   val \exists : [] math-cmd
%   val \nexists : [] math-cmd
%   val \bigcirc : [] math-cmd
%
%   val \cdot  : [] math-cmd
%   val \ldots : [] math-cmd
%   val \cdots : [] math-cmd
%   val \vdots : [] math-cmd
%   val \ddots : [] math-cmd
%   val \backddots : [] math-cmd
%
%   val \lim : [] math-cmd
%   val \colim : [] math-cmd
%   val \max : [] math-cmd
%   val \min : [] math-cmd
%   val \inf : [] math-cmd
%   val \sup : [] math-cmd
%   val \sin : [] math-cmd
%   val \cos : [] math-cmd
%   val \tan : [] math-cmd
%   val \cot : [] math-cmd
%   val \sec : [] math-cmd
%   val \csc : [] math-cmd
%   val \log : [] math-cmd
%   val \tr : [] math-cmd
%   val \det : [] math-cmd
%   val \dom : [] math-cmd
%   val \cod : [] math-cmd
%   val \Ker : [] math-cmd
%   val \Im : [] math-cmd
%
%   val \sum : [] math-cmd
%   val \prod : [] math-cmd
%   val \coprod : [] math-cmd
%   val \bigwedge : [] math-cmd
%   val \bigvee : [] math-cmd
%   val \bigcap : [] math-cmd
%   val \bigcup : [] math-cmd
%
%   val \land : [] math-cmd
%   val \lor : [] math-cmd
%
%   val \Leftarrow : [] math-cmd
%   val \Rightarrow : [] math-cmd
%   val \Leftrightarrow : [] math-cmd
%   val \Uparrow : [] math-cmd
%   val \Downarrow : [] math-cmd
%   val \Updownarrow : [] math-cmd
%   val \nRightarrow : [] math-cmd
%   val \nLeftarrow : [] math-cmd
%   val \nLeftrightarrow : [] math-cmd
%   val \leftarrow : [] math-cmd
%   val \rightarrow : [] math-cmd
%   val \uparrow : [] math-cmd
%   val \downarrow : [] math-cmd
%   val \updownarrow : [] math-cmd
%   val \nwarrow : [] math-cmd
%   val \nearrow : [] math-cmd
%   val \searrow : [] math-cmd
%   val \swarrow : [] math-cmd
%   val \nleftarrow : [] math-cmd
%   val \nrightarrow : [] math-cmd
%   val \nleftrightarrow : [] math-cmd
%   val \mapsto : [] math-cmd
%   val \hookleftarrow : [] math-cmd
%   val \hookrightarrow : [] math-cmd
%   val \rightarrowtail : [] math-cmd
%   val \leftarrowtail : [] math-cmd
%   val \twoheadleftarrow : [] math-cmd
%   val \twoheadrightarrow : [] math-cmd
%   val \twoheaduparrow : [] math-cmd
%   val \twoheaddownarrow : [] math-cmd
%   val \leftharpoonup : [] math-cmd
%   val \leftharpoondown : [] math-cmd
%   val \rightharpoonup : [] math-cmd
%   val \rightharpoondown : [] math-cmd
%   val \rightleftharpoons : [] math-cmd
%   val \upharpoonright : [] math-cmd
%   val \upharpoonleft : [] math-cmd
%   val \downharpoonright : [] math-cmd
%   val \downharpoonleft : [] math-cmd
%   val \longleftarrow : [] math-cmd
%   val \longrightarrow : [] math-cmd
%   val \longleftrightarrow : [] math-cmd
%   val \Longleftarrow : [] math-cmd
%   val \Longrightarrow : [] math-cmd
%   val \Longleftrightarrow : [] math-cmd
%   val \circlearrowleft : [] math-cmd
%   val \circlearrowright : [] math-cmd
%
%   val \between : [] math-cmd
%   val \pitchfork : [] math-cmd
%   val \intercal : [] math-cmd
%   val \ll : [] math-cmd
%   val \gg : [] math-cmd
%   val \lll : [] math-cmd
%   val \ggg : [] math-cmd
%   val \leqq : [] math-cmd
%   val \geqq : [] math-cmd
%   val \lneqq : [] math-cmd
%   val \gneqq : [] math-cmd
%   val \lnsim : [] math-cmd
%   val \gnsim : [] math-cmd
%   val \precnsim : [] math-cmd
%   val \succnsim : [] math-cmd
%   val \Subset : [] math-cmd
%   val \Supset : [] math-cmd
%   val \Cap : [] math-cmd
%   val \Cup : [] math-cmd
%   val \lhd : [] math-cmd
%   val \rhd : [] math-cmd
%   val \unlhd : [] math-cmd
%   val \unrhd : [] math-cmd
%   val \triangleleft : [] math-cmd
%   val \triangleright : [] math-cmd
%   val \trianglelefteq : [] math-cmd
%   val \trianglerighteq : [] math-cmd
%   val \backsim : [] math-cmd
%   val \backsimeq : [] math-cmd
%   val \eqcirc : [] math-cmd
%   val \cong : [] math-cmd
%   val \simneq : [] math-cmd
%   val \ncong : [] math-cmd
%   val \approx : [] math-cmd
%   val \napprox : [] math-cmd
%   val \approxeq : [] math-cmd
%   val \curlyeqprec : [] math-cmd
%   val \curlyeqsucc : [] math-cmd
%   val \lessdot : [] math-cmd
%   val \gtrdot : [] math-cmd
%   val \lesssim : [] math-cmd
%   val \gtrsim : [] math-cmd
%   val \nlesssim : [] math-cmd
%   val \ngtrsim : [] math-cmd
%   val \lessgtr : [] math-cmd
%   val \gtrless : [] math-cmd
%   val \nlessgtr : [] math-cmd
%   val \ngtrless : [] math-cmd
%   val \ntriangleleft : [] math-cmd
%   val \ntriangleright : [] math-cmd
%   val \ntrianglelefteq : [] math-cmd
%   val \ntrianglerighteq : [] math-cmd
%   val \lesseqgtr : [] math-cmd
%   val \gtreqless : [] math-cmd
%   val \nless : [] math-cmd
%   val \ngtr : [] math-cmd
%   val \nleq : [] math-cmd
%   val \ngeq : [] math-cmd
%   val \asymp : [] math-cmd
%   val \nasymp : [] math-cmd
%   val \circeq : [] math-cmd
%   val \Bumpeq : [] math-cmd
%   val \bumpeq : [] math-cmd
%   val \doteq : [] math-cmd
%   val \doteqdot : [] math-cmd
%   val \fallingdotseq : [] math-cmd
%   val \risingdotseq : [] math-cmd
%   val \mid : [] math-cmd
%   val \nmid : [] math-cmd
%   val \parallel : [] math-cmd
%   val \nparallel : [] math-cmd
%   val \Vvdash : [] math-cmd
%   val \VDash : [] math-cmd
%   val \coloncoloneq : [] math-cmd
%   val \leqslant : [] math-cmd
%   val \geqslant : [] math-cmd
%   val \dashV : [] math-cmd
%   val \Dashv : [] math-cmd
%   val \DashV : [] math-cmd
%   val \preceq : [] math-cmd
%   val \succeq : [] math-cmd
%
%   val \amalg : [] math-cmd
%   val \dotplus : [] math-cmd
%   val \divideontimes : [] math-cmd
%   val \odot : [] math-cmd
%   val \circledcirc : [] math-cmd
%   val \circledast : [] math-cmd
% %  val \circledeq : [] math-cmd
%   val \circleddash : [] math-cmd
%   val \boxplus : [] math-cmd
%   val \boxminus : [] math-cmd
%   val \boxtimes : [] math-cmd
%   val \boxdot : [] math-cmd
%   val \curlyvee : [] math-cmd
%   val \curlywedge : [] math-cmd
%   val \Join : [] math-cmd
%   val \ltimes : [] math-cmd
%   val \rtimes : [] math-cmd
%   val \leftthreetimes : [] math-cmd
%   val \rightthreetimes : [] math-cmd
%   val \wr : [] math-cmd
%
%   val \diamond : [] math-cmd
%   val \star : [] math-cmd
%   val \complement : [] math-cmd
%   val \angle : [] math-cmd
%   val \measuredangle : [] math-cmd
%   val \sphericalangle : [] math-cmd
%
%   val \int : [] math-cmd
%
%   val \ordd : [] math-cmd
%   val \partial : [] math-cmd
%   val \nabla : [] math-cmd
%
%   val \paren : [math] math-cmd
%   val \app : [math; math] math-cmd
%   val \angle-bracket : [math] math-cmd
%   val \brace : [math] math-cmd
%   val \sqbracket : [math] math-cmd
%   val \abs : [math] math-cmd
%   val \norm : [math] math-cmd
%   val \floor : [math] math-cmd
%   val \ceil : [math] math-cmd
%   val \set : [math] math-cmd
%   val \setsep : [math; math] math-cmd
%   val \cases : [(math * inline-text) list] math-cmd
%
%   val paren-left : paren
%   val paren-right : paren
%   val angle-left : length -> paren
%   val angle-right : length -> paren
%   val brace-left : paren
%   val brace-right : paren
%   val sqbracket-left : paren
%   val sqbracket-right : paren
%   val floor-left : paren
%   val floor-right : paren
%   val ceil-left : paren
%   val ceil-right : paren
%   val abs-left : paren
%   val abs-right : paren
%   val norm-left : paren
%   val norm-right : paren
%   val empty-paren : paren
%   val bar-middle : paren
%   val slash-middle : paren
%
%   % -- temporary --
%   val \synteq : [] math-cmd
%   val \tyjd : [math; math; math] math-cmd
%   val \and-also : [] math-cmd
%   val \tmabstyped : [math; math; math] math-cmd
%
% end
= struct

  val join msep mlst =
    match
      mlst |> List.fold-left (fun maccopt m -> (
        match maccopt with
        | None       -> Some(m)
        | Some(macc) -> Some(${#macc #msep #m})
        end
      )) None
    with
    | None       -> ${}
    | Some(macc) -> macc
    end


  val margin-ratio = 1.


  val inline ctx \math fml =
    script-guard Latin (embed-math ctx fml)

  val math \frac = math-frac

  val math \sqrt = math-radical None

  val math \lower = math-lower

  val math \upper = math-upper

  val math \text it =
    text-in-math MathOrd (fun ctx -> read-inline ctx it)

  val math \math-skip len =
    text-in-math MathOrd (fun _ -> inline-skip len)

  val math \math-color color m =
    math-color color m


  val math \mathord = math-group MathOrd MathOrd
  val math \mathbin = math-group MathBin MathBin
  val math \mathrel = math-group MathRel MathRel
  val math \mathop = math-group MathOp MathOp
  val math \mathprefix = math-group MathPrefix MathPrefix
  val math \mathpunct = math-group MathPunct MathPunct

  val math \math-style sty m =
    math-char-class sty m

  val math \mathrm m = ${\math-style!(MathRoman){#m}}
  val math \mathbf m = ${\math-style!(MathBoldRoman){#m}}
  val math \mathcal m = ${\math-style!(MathScript){#m}}
  val math \mathfrak m = ${\math-style!(MathFraktur){#m}}
  val math \mathbb m = ${\math-style!(MathDoubleStruck){#m}}
  val math \bm m = ${\math-style!(MathBoldItalic){#m}}


  val math \math-style-token sty s =
    text-in-math MathOrd (fun ctx -> (
      let sm = convert-string-for-math ctx sty s in
      embed-math ctx (math-char MathOrd sm)
    ))

  val math \mathit-token s = ${\math-style-token!(MathItalic)!(s)}
  val math \mathrm-token s = ${\math-style-token!(MathRoman)!(s)}
  val math \mathbf-token s = ${\math-style-token!(MathBoldRoman)!(s)}


  val math-scheme ctx tagopt m =
    let ib = embed-math ctx m in
      match tagopt with
      | None      -> line-break true true ctx (inline-fil ++ ib ++ inline-fil)
      | Some(tag) -> line-break true true ctx (inline-fil ++ ib ++ inline-fil ++ read-inline ctx tag)
      end


  val block ctx +math ?(tag = tagopt) m =
    math-scheme ctx tagopt m


  val inline ctx \eqn ?(tag = tagopt) m =
    inline-fil ++
      embed-block-breakable ctx (math-scheme ctx tagopt m)
        ++ omit-skip-after


  val block ctx +math-list mlst =
    let mingap = get-font-size ctx *' 2. in
    let ib-fil =
      discretionary 100 (inline-skip mingap ++ inline-fil) inline-fil inline-fil
    in
    let ib =
      mlst |> List.fold-left-adjacent (fun ibacc m _ optnext -> (
        let ib-after =
          match optnext with
          | None    -> inline-fil
          | Some(_) -> ib-fil
          end
        in
          ibacc ++ embed-math ctx m ++ ib-after
      )) inline-fil
    in
    let margin = get-font-size ctx *' margin-ratio in
    let ctx =
      ctx |> set-min-gap-of-lines 12pt
          |> set-paragraph-margin margin margin
    in
      line-break true true ctx ib


  val inline ctx \math-list mlst =
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+math-list(mlst);>)
        ++ omit-skip-after


  val block ctx +align mlstlst =
    let vlen = 4pt in
    let lengap = get-font-size ctx *' 2. in
    let celllstlst =
      mlstlst |> List.map (fun mlst -> (
        mlst |> List.mapi-adjacent (fun index m _ mnextopt -> (
          let ibm = embed-math ctx m in
          let ib =
            match mnextopt with
            | None ->
                ibm

            | Some(mnext) ->
                let ibspaceopt = space-between-maths ctx m mnext in
                match ibspaceopt with
                | None          -> ibm
                | Some(ibspace) -> ibm ++ ibspace
                end
            end
          in
          let ib =
            if index mod 2 == 0 then
              inline-fil ++ ib
            else
              match mnextopt with
              | None    -> ib ++ inline-fil
              | Some(_) -> ib ++ inline-fil ++ inline-skip lengap
              end
          in
            NormalCell((0pt, 0pt, vlen, vlen), ib)
        ))
      ))
    in
    let margin = get-font-size ctx *' margin-ratio in
      line-break true true (ctx |> set-paragraph-margin margin margin)
        (inline-fil ++ (tabular celllstlst (fun _ _ -> [])) ++ inline-fil)
        % temporary


  val inline ctx \align mlstlst =
    inline-fil ++
      embed-block-breakable ctx (read-block ctx '<+align(mlstlst);>)
        ++ omit-skip-after


  val math-list lst =
    lst |> List.fold-left math-concat (math-char MathOrd ` `)


  val single cp = string-unexplode [cp]


  val greek-lowercase cp cpb =
    let s = single cp in
    let sb = single cpb in
      math-variant-char MathOrd (|
        italic        = s,
        bold-italic   = sb,
        roman         = s,
        bold-roman    = sb,
        script        = s,
        bold-script   = sb,
        fraktur       = s,
        bold-fraktur  = sb,
        double-struck = s,
      |)


  val greek-uppercase cp cpb cpr cprb =
    let s = single cp in
    let sb = single cpb in
    let sr = single cpr in
    let srb = single cprb in
      math-variant-char MathOrd (|
        italic        = s,
        bold-italic   = sb,
        roman         = sr,
        bold-roman    = srb,
        script        = s,
        bold-script   = sb,
        fraktur       = s,
        bold-fraktur  = sb,
        double-struck = s,
      |)

  val math \alpha    = greek-lowercase 0x1D6FC 0x1D736
  val math \beta     = greek-lowercase 0x1D6FD 0x1D737
  val math \gamma    = greek-lowercase 0x1D6FE 0x1D738
  val math \delta    = greek-lowercase 0x1D6FF 0x1D739
  val math \epsilon  = greek-lowercase 0x1D700 0x1D73A
  val math \zeta     = greek-lowercase 0x1D701 0x1D73B
  val math \eta      = greek-lowercase 0x1D702 0x1D73C
  val math \theta    = greek-lowercase 0x1D703 0x1D73D
  val math \iota     = greek-lowercase 0x1D704 0x1D73E
  val math \kappa    = greek-lowercase 0x1D705 0x1D73F
  val math \lambda   = greek-lowercase 0x1D706 0x1D740
  val math \mu       = greek-lowercase 0x1D707 0x1D741
  val math \nu       = greek-lowercase 0x1D708 0x1D742
  val math \xi       = greek-lowercase 0x1D709 0x1D743
  val math \omicron  = greek-lowercase 0x1D70A 0x1D744
  val math \pi       = greek-lowercase 0x1D70B 0x1D745
  val math \rho      = greek-lowercase 0x1D70C 0x1D746
  val math \sigma    = greek-lowercase 0x1D70E 0x1D748
  val math \tau      = greek-lowercase 0x1D70F 0x1D749
  val math \upsilon  = greek-lowercase 0x1D710 0x1D74A
  val math \phi      = greek-lowercase 0x1D711 0x1D74B
  val math \chi      = greek-lowercase 0x1D712 0x1D74C
  val math \psi      = greek-lowercase 0x1D713 0x1D74D
  val math \omega    = greek-lowercase 0x1D714 0x1D74E

  val math \Alpha    = greek-uppercase 0x1D6E2 0x1D71C 0x0391 0x1D6A8
  val math \Beta     = greek-uppercase 0x1D6E3 0x1D71D 0x0392 0x1D6A9
  val math \Gamma    = greek-uppercase 0x1D6E4 0x1D71E 0x0393 0x1D6AA
  val math \Delta    = greek-uppercase 0x1D6E5 0x1D71F 0x0394 0x1D6AB
  val math \Epsilon  = greek-uppercase 0x1D6E6 0x1D720 0x0395 0x1D6AC
  val math \Zeta     = greek-uppercase 0x1D6E7 0x1D721 0x0396 0x1D6AD
  val math \Eta      = greek-uppercase 0x1D6E8 0x1D722 0x0397 0x1D6AE
  val math \Theta    = greek-uppercase 0x1D6E9 0x1D723 0x0398 0x1D6AF
  val math \Iota     = greek-uppercase 0x1D6EA 0x1D724 0x0399 0x1D6B0
  val math \Kappa    = greek-uppercase 0x1D6EB 0x1D725 0x039A 0x1D6B1
  val math \Lambda   = greek-uppercase 0x1D6EC 0x1D726 0x039B 0x1D6B2
  val math \Mu       = greek-uppercase 0x1D6ED 0x1D727 0x039C 0x1D6B3
  val math \Nu       = greek-uppercase 0x1D6EE 0x1D728 0x039D 0x1D6B4
  val math \Xi       = greek-uppercase 0x1D6EF 0x1D729 0x039E 0x1D6B5
  val math \Omicron  = greek-uppercase 0x1D6F0 0x1D72A 0x039F 0x1D6B6
  val math \Pi       = greek-uppercase 0x1D6F1 0x1D72B 0x03A0 0x1D6B7
  val math \Rho      = greek-uppercase 0x1D6F2 0x1D72C 0x03A1 0x1D6B8
  val math \Sigma    = greek-uppercase 0x1D6F4 0x1D72E 0x03A3 0x1D6BA
  val math \Tau      = greek-uppercase 0x1D6F5 0x1D72F 0x03A4 0x1D6BB
  val math \Upsilon  = greek-uppercase 0x1D6F6 0x1D730 0x03A5 0x1D6BC
  val math \Phi      = greek-uppercase 0x1D6F7 0x1D731 0x03A6 0x1D6BD
  val math \Chi      = greek-uppercase 0x1D6F8 0x1D732 0x03A7 0x1D6BE
  val math \Psi      = greek-uppercase 0x1D6F9 0x1D733 0x03A8 0x1D6BF
  val math \Omega    = greek-uppercase 0x1D6FA 0x1D734 0x03A9 0x1D6C0

  val ord = math-char MathOrd
  val bin = math-char MathBin
  val rel = math-char MathRel
  val op = math-char MathOp
  val punct = math-char MathPunct
  val prefix = math-char MathPrefix

  val vop-scheme charf s =
    let mop = charf MathOp s in
      math-pull-in-scripts MathOp MathOp
        (fun moptS moptT -> (
          let m =
            match moptS with
            | None     -> mop
            | Some(mS) -> math-lower mop mS
            end
          in
            match moptT with
            | None     -> m
            | Some(mT) -> math-upper m mT
            end
        ))

  val bigop = vop-scheme math-big-char
  val vop = vop-scheme math-char

  val math \to    = rel `→`
  val math \pm    = bin `±`
  val math \mp    = bin `∓`
  val math \times = bin `×`
  val math \setminus = bin `∖`
  val math \ast = bin `∗`
  val math \circ = bin `∘`
  val math \bullet = bin `∙`
  val math \cap = bin `∩`
  val math \cup = bin `∪`
  val math \uplus = bin `⊎`
  val math \sqcap = bin `⊓`
  val math \sqcup = bin `⊔`
  val math \wedge = bin `∧`
  val math \vee   = bin `∨`
  val math \oplus = bin `⊕`
  val math \ominus = bin `⊖`
  val math \otimes = bin `⊗`
  val math \oslash = bin `⊘`

  val math \vdash = rel `⊢`
  val math \nvdash = rel `⊬`
  val math \dashv = rel `⊣`
  val math \vDash = rel `⊨`
  val math \nvDash = rel `⊭`
  val math \Vdash = rel `⊩`
  val math \nVdash = rel `⊮`

  val math \colon-rel = rel `:`

  val math \leq = rel `≤`
  val math \geq = rel `≥`
  val math \equiv = rel `≡`
  val math \nequiv = rel `≢`
  val math \neq = rel `≠`
  val math \sim = rel `∼`
  val math \nsim = rel `≁`
  val math \simeq = rel `≃`
  val math \nsimeq = rel `≄`
  val math \propto = rel `∝`
  val math \coloneq = rel `≔`
  val math \eqcolon = rel `≕`

  val math \in = rel `∈`
  val math \nin = rel `∉`
  val math \ni = rel `∋`
  val math \nni = rel `∌`
  val math \subset = rel `⊂`
  val math \supset = rel `⊃`
  val math \nsubset = rel `⊄`
  val math \nsupset = rel `⊅`
  val math \subseteq = rel `⊆`
  val math \supseteq = rel `⊇`
  val math \nsubseteq = rel `⊈`
  val math \nsupseteq = rel `⊉`
  val math \subsetneq = rel `⊊`
  val math \supsetneq = rel `⊋`
  val math \sqsubset = rel `⊏`
  val math \sqsupset = rel `⊐`
  val math \sqsubseteq = rel `⊑`
  val math \sqsupseteq = rel `⊒`
  val math \nsqsubseteq = rel `⋢`
  val math \nsqsupseteq = rel `⋣`
  val math \sqsubsetneq = rel `⋤`
  val math \sqsupsetneq = rel `⋥`
  val math \prec = rel `≺`
  val math \succ = rel`≻`
  val math \nprec = rel `⊀`
  val math \nsucc = rel `⊁`
  val math \preccurlyeq = rel`≼`
  val math \succcurlyeq = rel `≽`
  val math \precsim = rel `≾`
  val math \succsim = rel `≿`
  val math \npreccurlyeq = rel `⋠`
  val math \nsucccurlyeq = rel `⋡`

  val math \emptyset = ord `∅`
  val math \infty = ord `∞`
  val math \top = ord `⊤`
  val math \bot = ord `⊥`
  val math \therefore = ord `∴`
  val math \because = ord `∵`
  val math \forall = ord `∀`
  val math \exists = ord `∃`
  val math \nexists = ord `∄`
  val math \bigcirc = ord `◯`

  val math \cdot  = bin `⋅`
  val math \ldots = ord `…`
  val math \cdots = math-char MathInner `⋯`
  val math \vdots = ord `⋮`
  val math \ddots = ord `⋱`
  val math \backddots = ord `⋰`

  val math \lim = vop `lim`
  val math \colim = vop `colim`
  val math \max = vop `max`
  val math \min = vop `min`
  val math \inf = vop `inf`
  val math \sup = vop `sup`
  val math \sin = op `sin`
  val math \cos = op `cos`
  val math \tan = op `tan`
  val math \cot = op `cot`
  val math \sec = op `sec`
  val math \csc = op `csc`
  val math \log = op `log`
  val math \tr  = op `tr`
  val math \det = op `det`
  val math \dom = op `dom`
  val math \cod = op `cod`
  val math \Ker = op `Ker`
  val math \Im = op `Im`

  val math \sum = bigop `∑`
  val math \prod = bigop `∏`
  val math \coprod = bigop `∐`
  val math \bigwedge = bigop `⋀`
  val math \bigvee = bigop `⋁`
  val math \bigcap = bigop `⋂`
  val math \bigcup = bigop `⋃`

  val math \land = rel `∧`
  val math \lor  = rel `∨`

  val math \Leftarrow = rel `⇐`
  val math \Rightarrow = rel `⇒`
  val math \Leftrightarrow = rel `⇔`
  val math \Uparrow = rel `⇑`
  val math \Downarrow = rel `⇓`
  val math \Updownarrow = rel `⇕`
  val math \nRightarrow = rel `⇍`
  val math \nLeftarrow = rel `⇏`
  val math \nLeftrightarrow = rel `⇎`
  val math \leftarrow = rel `←`
  val math \rightarrow = rel `→`
  val math \uparrow = rel `↑`
  val math \downarrow = rel `↓`
  val math \updownarrow = rel `↕`
  val math \nwarrow = rel `↖`
  val math \nearrow = rel `↗`
  val math \searrow = rel `↘`
  val math \swarrow = rel `↙`
  val math \nleftarrow = rel `↚`
  val math \nrightarrow = rel `↛`
  val math \nleftrightarrow = rel `↮`
  val math \mapsto = rel `↦`
  val math \hookleftarrow = rel `↩`
  val math \hookrightarrow = rel `↪`
  val math \rightarrowtail = rel `↣`
  val math \leftarrowtail = rel `↢`
  val math \twoheadleftarrow = rel `↞`
  val math \twoheadrightarrow = rel `↠`
  val math \twoheaduparrow = rel `↟`
  val math \twoheaddownarrow = rel `↡`
  val math \leftharpoonup = rel `↼`
  val math \leftharpoondown = rel `↽`
  val math \rightharpoonup = rel `⇀`
  val math \rightharpoondown = rel `⇁`
  val math \rightleftharpoons = rel `⇌`
  val math \upharpoonright = rel `↾`
  val math \upharpoonleft = rel `↿`
  val math \downharpoonright = rel `⇂`
  val math \downharpoonleft = rel `⇃`
  val math \longleftarrow = rel `⟵`
  val math \longrightarrow = rel `⟶`
  val math \longleftrightarrow = rel `⟷`
  val math \Longleftarrow = rel `⟸`
  val math \Longrightarrow = rel `⟹`
  val math \Longleftrightarrow = rel `⟺`
  val math \circlearrowleft = rel `↺`
  val math \circlearrowright = rel `↻`

  val math \between = rel `≬`
  val math \pitchfork = rel `⋔`
  val math \intercal = rel `⊺`
  val math \ll = rel `≪`
  val math \gg = rel `≫`
  val math \lll = rel `⋘`
  val math \ggg = rel `⋙`
  val math \leqq = rel `≦`
  val math \geqq = rel `≧`
  val math \lneqq = rel `≨`
  val math \gneqq = rel `≩`
  val math \lnsim = rel `⋦`
  val math \gnsim = rel `⋧`
  val math \precnsim = rel `⋨`
  val math \succnsim = rel `⋩`
  val math \Subset = rel `⋐`
  val math \Supset = rel `⋑`
  val math \Cap = bin `⋒`
  val math \Cup = bin `⋓`
  val math \lhd = rel `⊲`
  val math \rhd = rel `⊳`
  val math \unlhd = rel `⊴`
  val math \unrhd = rel `⊵`
  val math \triangleleft = rel `⊲`
  val math \triangleright = rel `⊳`
  val math \trianglelefteq = rel `⊴`
  val math \trianglerighteq = rel `⊵`
  val math \backsim = rel `∽`
  val math \backsimeq = rel `⋍`
  val math \eqcirc = rel `≖`
  val math \cong = rel `≅`
  val math \simneq = rel `≆`
  val math \ncong = rel `≇`
  val math \approx = rel `≈`
  val math \napprox = rel `≉`
  val math \approxeq = rel `≊`
  val math \curlyeqprec = rel `⋞`
  val math \curlyeqsucc = rel `⋟`
  val math \lessdot = rel `⋖`
  val math \gtrdot = rel `⋗`
  val math \lesssim = rel `≲`
  val math \gtrsim = rel `≳`
  val math \nlesssim = rel `≴`
  val math \ngtrsim = rel `≵`
  val math \lessgtr = rel `≶`
  val math \gtrless = rel `≷`
  val math \nlessgtr = rel `≸`
  val math \ngtrless = rel `≹`
  val math \ntriangleleft = rel `⋪`
  val math \ntriangleright = rel `⋫`
  val math \ntrianglelefteq = rel `⋬`
  val math \ntrianglerighteq = rel `⋭`
  val math \lesseqgtr = rel `⋚`
  val math \gtreqless = rel `⋛`
  val math \nless = rel `≮`
  val math \ngtr = rel `≯`
  val math \nleq = rel `≰`
  val math \ngeq = rel `≱`
  val math \asymp = rel `≍`
  val math \nasymp = rel `≭`
  val math \circeq = rel `≗`
  val math \Bumpeq = rel `≎`
  val math \bumpeq = rel `≏`
  val math \doteq = rel `≐`
  val math \doteqdot = rel `≑`
  val math \fallingdotseq = rel `≒`
  val math \risingdotseq = rel `≓`
  val math \mid = rel `∣`
  val math \nmid = rel `∤`
  val math \parallel = rel `∥`
  val math \nparallel = rel `∦`
  val math \Vvdash = rel `⊪`
  val math \VDash = rel `⊫`
  val math \coloncoloneq = rel `⩴`
  val math \leqslant = rel `⩽`
  val math \geqslant = rel `⩾`
  val math \dashV = rel `⫣`
  val math \Dashv = rel `⫤`
  val math \DashV = rel `⫥`
  val math \preceq = rel `⪯`
  val math \succeq = rel `⪰`

  val math \amalg = bin `⨿`
  val math \dotplus = bin `∔`
  val math \divideontimes = bin `⋇`
  val math \odot = bin `⊙`
  val math \circledcirc = bin `⊚`
  val math \circledast = bin `⊛`
%  val math \circledeq = bin `⊜`
  val math \circleddash = bin `⊝`
  val math \boxplus = bin `⊞`
  val math \boxminus = bin `⊟`
  val math \boxtimes = bin `⊠`
  val math \boxdot = bin `⊡`
  val math \curlyvee = bin `⋎`
  val math \curlywedge = bin `⋏`
  val math \Join = bin `⋈`
  val math \ltimes = bin `⋉`
  val math \rtimes = bin `⋊`
  val math \leftthreetimes = bin `⋋`
  val math \rightthreetimes = bin `⋌`
  val math \wr = bin `≀`

  val math \diamond = ord `⋄`
  val math \star = ord `⋆`
  val math \complement = ord `∁`
  val math \angle = ord `∠`
  val math \measuredangle = ord `∡`
  val math \sphericalangle = rel `∢`

  val math \ordd = prefix `d`
  val math \partial = prefix `∂`
  val math \nabla  = prefix `∇`

%% -- for Latin Modern Math --
  val math \int =
    let kernfL _ _ = 0pt in
    let kernfR fontsize ypos = fontsize *' 0.45 in
      math-big-char-with-kern MathOp `∫` kernfL kernfR

%% -- for Cambria Math --
%  val math \int =
%    let kernfL _ _ = 0pt in
%    let kernfR fontsize ypos = fontsize *' 0.2 in
%      math-big-char-with-kern MathOp `∫` kernfL kernfR

  val math-space =
    text-in-math MathOrd (fun ctx -> inline-skip 30pt)

  val math \and-also = math-space

  val math \tyjd tyenv tm ty =
    ${#tyenv \vdash #tm \colon-rel #ty}

  val math \synteq = ${\equiv}

  val math \dot-punct =
    math-char MathPunct `.`

  val math \tmabstyped var ty body =
    ${\lambda #var \colon-rel #ty \dot-punct #body}

  val math \npe =
    math-color (RGB(1., 0., 0.)) (math-char-class MathRoman ${e})

  val math \bi m =
    math-char-class MathBoldItalic m

  val half-length hgt dpt hgtaxis fontsize =
    let minhalflen = fontsize *' 0.5 in
    let lenappend = fontsize *' 0.1 in
      Pervasives.length-max minhalflen ((Pervasives.length-max (hgt -' hgtaxis) (hgtaxis +' dpt)) +' lenappend)

  val angle-left thk hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let widparen = halflen *' 0.375 in
    let wid = widparen +' fontsize *' 0.1 in
    let path (xpos, ypos) =
      start-path (xpos +' wid, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid -' widparen, ypos +' hgtaxis)
        |> line-to (xpos +' wid, ypos +' hgtaxis -' halflen)
        |> terminate-path
    in
    let graphics point = [ stroke thk color (path point), ] in
    let kerninfo y =
      let widkern = widparen in
      let r = 0. in
      let gap = Pervasives.length-abs (y -' hgtaxis) in
        if halflen *' r <' gap then
          widkern *' ((gap -' halflen *' r) /' (halflen *' (1. -. r)))
        else
          0pt
    in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  val angle-right thk hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let widparen = halflen *' 0.375 in
    let wid = widparen +' fontsize *' 0.1 in
    let path (xpos, ypos) =
      start-path (xpos, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' widparen, ypos +' hgtaxis)
        |> line-to (xpos, ypos +' hgtaxis -' halflen)
        |> terminate-path
    in
    let graphics point = [ stroke thk color (path point), ] in
    let kerninfo y =
      let widkern = widparen in
      let r = 0. in
      let gap = Pervasives.length-abs (y -' hgtaxis) in
        if halflen *' r <' gap then
          widkern *' ((gap -' halflen *' r) /' (halflen *' (1. -. r)))
        else
          0pt
    in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  val math \angle-bracket =
    math-paren (angle-left 0.5pt) (angle-right 0.5pt)

  val paren-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.075 +' halflen *' 0.01 in
    let w2 = halflen *' 0.25 in %temporary
    let w-extra = fontsize *' 0.1 in
    let t1 = fontsize *' 0.025 in
    let t2 = fontsize *' 0.025 in

    let qA = halflen *' 0.35 in
    let p1 = (w1 +' w2) *' 0.75 in
    let q1 = halflen *' 0.3 in

    let qB = halflen *' 0.45 in
    let p2 = w2 *' 0.5 in
    let q2 = halflen *' 0.2 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let x0 = xpos +' w0 in
      let x1 = x0 +' w1 in
      let x2 = x1 +' w2 in
      start-path (x2, ycenter +' halflen)
        |> bezier-to (x2 -' p1, ycenter +' halflen -' q1) (x0, ycenter +' qA) (x0, ycenter)
        |> bezier-to (x0, ycenter -' qA) (x2 -' p1, ycenter -' halflen +' q1) (x2, ycenter -' halflen)
        |> line-to (x2 +' t1, ycenter -' halflen +' t2)
        |> bezier-to (x2 -' p2, ycenter -' halflen +' q2) (x1, ycenter -' qB) (x1, ycenter)
        |> bezier-to (x1, ycenter +' qB) (x2 -' p2, ycenter +' halflen -' q2) (x2 +' t1, ycenter +' halflen -' t2)
        |> close-with-line
    in
    let graphics point = [ fill color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics (w0 +' w1 +' w2 +' w-extra) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)

  val paren-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.075 +' halflen *' 0.01 in
    let w2 = halflen *' 0.25 in %temporary
    let w-extra = fontsize *' 0.1 in
    let t1 = 0pt -' fontsize *' 0.025 in
    let t2 = fontsize *' 0.025 in

    let qA = halflen *' 0.35 in
    let p1 = 0pt -' (w1 +' w2) *' 0.75 in
    let q1 = halflen *' 0.3 in

    let qB = halflen *' 0.45 in
    let p2 = 0pt -' w2 *' 0.5 in
    let q2 = halflen *' 0.2 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let x0 = xpos +' w-extra +' w2 +' w1 in
      let x1 = xpos +' w-extra +' w2 in
      let x2 = xpos +' w-extra in
      start-path (x2, ycenter +' halflen)
        |> bezier-to (x2 -' p1, ycenter +' halflen -' q1) (x0, ycenter +' qA) (x0, ycenter)
        |> bezier-to (x0, ycenter -' qA) (x2 -' p1, ycenter -' halflen +' q1) (x2, ycenter -' halflen)
        |> line-to (x2 +' t1, ycenter -' halflen +' t2)
        |> bezier-to (x2 -' p2, ycenter -' halflen +' q2) (x1, ycenter -' qB) (x1, ycenter)
        |> bezier-to (x1, ycenter +' qB) (x2 -' p2, ycenter +' halflen -' q2) (x2 +' t1, ycenter +' halflen -' t2)
        |> close-with-line
    in
    let graphics point = [ fill color (path point), ] in
    let widparen = w0 +' w1 +' w2 +' w-extra in
    let kerninfo y =
      let widkern = widparen *' 0.5 in
      let r = 0.25 in
      let gap = Pervasives.length-abs (y -' hgtaxis) in
        let diff = Pervasives.length-min (gap -' halflen *' r) (halflen *' (1. -. r)) in
        if 0pt <' diff then
          widkern *' (diff /' (halflen *' (1. -. r)))
        else
          0pt
    in
      (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \paren =
    math-paren paren-left paren-right


  val math \app m1 m2 = ${#m1 \paren{#m2}}


  val brace-left hgt dpt hgtaxis fontsize color =

    let t0 = fontsize *' 0.0125 in
    let t4 = fontsize *' 0.025 in

    let halflen = half-length hgt dpt hgtaxis fontsize in
    let h-straight =  halflen *' 0.9 -' fontsize *' 0.3 in
    let w-straight = h-straight *' 0.15 in
    let w1 = fontsize *' 0.0125 in
    let w2 = fontsize *' 0.02 in
    let w5 = fontsize *' 0.01 in
    let w6 = fontsize *' 0.015 in
    let w-extra = fontsize *' 0.1 in

    let x0 = fontsize *' 0.125 in
    let x1 = fontsize *' 0.25 in
    let x2 = x1 -' w-straight in
    let x3 = x2 +' fontsize *' 0.2 in
    let x4 = x3 +' fontsize *' 0.01 in
    let x5 = x2 +' fontsize *' 0.0625 in
    let x6 = x5 +' w-straight in
    let x7 = fontsize *' 0.225 in

    let p0 = fontsize *' 0.2 in
    let p1 = x1 +' w1 in
    let p2 = x2 -' w2 in
    let p3 = x3 -' fontsize *' 0.1 in
    let p4 = x4 -' fontsize *' 0.09 in
    let p5 = x5 -' w5 in
    let p6 = x6 +' w6 in
    let p7 = fontsize *' 0.3 in

    let y0 = t0 in
    let y1 = fontsize *' 0.125 in
    let y2 = y1 +' h-straight in
    let y3 = halflen in
    let y4 = halflen -' t4 in
    let y5 = halflen -' fontsize *' 0.175 in
    let y6 = y5 -' h-straight in
    let y7 = 0pt in

    let q0 = y0 in
    let q1 = y1 -' (y2 -' y1) *' ((x1 -' p1) /' (x2 -' x1)) in
    let q2 = y2 +' (y2 -' y1) *' ((p2 -' x2) /' (x2 -' x1)) in
    let q3 = halflen -' fontsize *' 0.00875 in
    let q4 = halflen -' t4 -' fontsize *' 0.01 in
    let q5 = y5 +' (y5 -' y6) *' ((p5 -' x5) /' (x5 -' x6)) in
    let q6 = y6 -' (y5 -' y6) *' ((x6 -' p6) /' (x5 -' x6)) in
    let q7 = fontsize *' 0.025 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x, ycenter +' y) in
      let fN (x, y) = (xpos +' x, ycenter -' y) in
        start-path   (fP (x0, y0))
          |> bezier-to (fP (p0, q0)) (fP (p1, q1)) (fP (x1, y1))
          |> line-to (fP (x2, y2))
          |> bezier-to (fP (p2, q2)) (fP (p3, q3)) (fP (x3, y3))
          |> line-to (fP (x4, y4))
          |> bezier-to (fP (p4, q4)) (fP (p5, q5)) (fP (x5, y5))
          |> line-to (fP (x6, y6))
          |> bezier-to (fP (p6, q6)) (fP (p7, q7)) (fP (x7, y7))
          |> bezier-to (fN (p7, q7)) (fN (p6, q6)) (fN (x6, y6))
          |> line-to (fN (x5, y5))
          |> bezier-to (fN (p5, q5)) (fN (p4, q4)) (fN (x4, y4))
          |> line-to (fN (x3, y3))
          |> bezier-to (fN (p3, q3)) (fN (p2, q2)) (fN (x2, y2))
          |> line-to (fN (x1, y1))
          |> bezier-to (fN (p1, q1)) (fN (p0, q0)) (fN (x0, y0))
          |> close-with-line
    in
    let graphics point = [ fill color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics (x4 +' w-extra) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val brace-right hgt dpt hgtaxis fontsize color =

    let t0 = fontsize *' 0.0125 in
    let t4 = fontsize *' 0.025 in

    let halflen = half-length hgt dpt hgtaxis fontsize in
    let h-straight =  halflen *' 0.9 -' fontsize *' 0.3 in
    let w-straight = h-straight *' 0.15 in
    let w1 = fontsize *' 0.0125 in
    let w2 = fontsize *' 0.02 in
    let w5 = fontsize *' 0.01 in
    let w6 = fontsize *' 0.015 in
    let w-extra = fontsize *' 0.1 in

    let x0 = w-extra +' fontsize *' 0.125 in
    let x1 = w-extra +' fontsize *' 0.25 in
    let x2 = x1 -' w-straight in
    let x3 = x2 +' fontsize *' 0.2 in
    let x4 = x3 +' fontsize *' 0.01 in
    let x5 = x2 +' fontsize *' 0.0625 in
    let x6 = x5 +' w-straight in
    let x7 = w-extra +' fontsize *' 0.225 in

    let p0 = w-extra +' fontsize *' 0.2 in
    let p1 = x1 +' w1 in
    let p2 = x2 -' w2 in
    let p3 = x3 -' fontsize *' 0.1 in
    let p4 = x4 -' fontsize *' 0.09 in
    let p5 = x5 -' w5 in
    let p6 = x6 +' w6 in
    let p7 = w-extra +' fontsize *' 0.3 in

    let y0 = t0 in
    let y1 = fontsize *' 0.125 in
    let y2 = y1 +' h-straight in
    let y3 = halflen in
    let y4 = halflen -' t4 in
    let y5 = halflen -' fontsize *' 0.175 in
    let y6 = y5 -' h-straight in
    let y7 = 0pt in

    let q0 = y0 in
    let q1 = y1 -' (y2 -' y1) *' ((x1 -' p1) /' (x2 -' x1)) in
    let q2 = y2 +' (y2 -' y1) *' ((p2 -' x2) /' (x2 -' x1)) in
    let q3 = halflen -' fontsize *' 0.00875 in
    let q4 = halflen -' t4 -' fontsize *' 0.01 in
    let q5 = y5 +' (y5 -' y6) *' ((p5 -' x5) /' (x5 -' x6)) in
    let q6 = y6 -' (y5 -' y6) *' ((x6 -' p6) /' (x5 -' x6)) in
    let q7 = fontsize *' 0.025 in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x4 -' x +' w-extra, ycenter +' y) in
      let fN (x, y) = (xpos +' x4 -' x +' w-extra, ycenter -' y) in
        start-path   (fP (x0, y0))
          |> bezier-to (fP (p0, q0)) (fP (p1, q1)) (fP (x1, y1))
          |> line-to (fP (x2, y2))
          |> bezier-to (fP (p2, q2)) (fP (p3, q3)) (fP (x3, y3))
          |> line-to (fP (x4, y4))
          |> bezier-to (fP (p4, q4)) (fP (p5, q5)) (fP (x5, y5))
          |> line-to (fP (x6, y6))
          |> bezier-to (fP (p6, q6)) (fP (p7, q7)) (fP (x7, y7))
          |> bezier-to (fN (p7, q7)) (fN (p6, q6)) (fN (x6, y6))
          |> line-to (fN (x5, y5))
          |> bezier-to (fN (p5, q5)) (fN (p4, q4)) (fN (x4, y4))
          |> line-to (fN (x3, y3))
          |> bezier-to (fN (p3, q3)) (fN (p2, q2)) (fN (x2, y2))
          |> line-to (fN (x1, y1))
          |> bezier-to (fN (p1, q1)) (fN (p0, q0)) (fN (x0, y0))
          |> close-with-line
    in
    let graphics point = [ fill color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics x4 (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val brace-left-long hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in

    let t0B = fontsize *' 0.05 in
    let t1A = fontsize *' 0.05 in
    let t1B = fontsize *' 0.025 in
    let t2A = halflen *' 0.1 in
    let t2B = halflen *' 0.15 in
    let t3A = fontsize *' 0.05 in

    let (x0, y0) = (fontsize *' 0.005, fontsize *' 0.005) in
    let (p0B, q0B) = (x0 +' t0B, y0) in

    let (x1, y1) = (fontsize *' 0.2, fontsize *' 0.2) in
    let (p1A, q1A) = (x1, y1 -' t1A) in
    let (p1B, q1B) = (x1, y1 +' t1B) in

    let theta = atan2 (x1 /' 1pt) (halflen /' 1pt) in

    let (x2, y2) = (fontsize *' 0.175, halflen *' 0.5) in

    let (p2A, q2A) = (x2 +' t2A *' (sin theta), y2 -' t2A *' (cos theta)) in
    let (p2B, q2B) = (x2 -' t2B *' (sin theta), y2 +' t2B *' (cos theta)) in

    let (x3, y3) = (fontsize *' 0.15, halflen -' fontsize *' 0.2) in

    let (p3A, q3A) = (x3, y3 -' t3A) in

    let path (xpos, ypos) =
      let ycenter = ypos +' hgtaxis in
      let fP (x, y) = (xpos +' x, ycenter +' y) in
      let fN (x, y) = (xpos +' x, ycenter -' y) in
%        start-path (fP (x0, y0))
%          |> bezier-to (fP (p0B, q0B)) (fP (p1A, q1A)) (fP (x1, y1))
%          |> bezier-to (fP (p1B, q1B)) (fP (p2A, q2A)) (fP (x2, y2))
%          |> close-with-line
        Gr.poly-line (fP (x0, y0)) [
          fP (p0B, q0B), fP (p1A, q1A), fP (x1, y1),
          fP (p1B, q1B), fP (p2A, q2A), fP (x2, y2),
          fP (p2B, q2B), fP (p3A, q3A), fP (x3, y3),
        ]
    in
    let graphics point = [ fill color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics (x2) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \brace =
    math-paren brace-left brace-right


  val bar-middle hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let halfwid = fontsize *' 0.5 in
    let graphics (x, y) =
      [ stroke 0.5pt color (Gr.line (x +' halfwid, y +' hgtaxis -' halflen) (x +' halfwid, y +' hgtaxis +' halflen)), ]
    in
    let kerninfo _ = 0pt in
      (inline-graphics (halfwid *' 2.) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \setsep m1 m2 =
    math-paren-with-middle brace-left brace-right bar-middle [m1, m2]


  val slash-middle hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let halfwid = halflen *' 0.5 in
    let graphics (x, y) =
      [ stroke 0.5pt color (Gr.line (x, y +' hgtaxis -' halflen) (x +' halfwid *' 2., y +' hgtaxis +' halflen)), ]
    in
    let kerninfo _ = 0pt in
      (inline-graphics (halfwid *' 2.) (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val bracket-metrics fontsize halflen =
    let w0 = fontsize *' 0.1 in
    let w1 = fontsize *' 0.05 +' halflen *' 0.005 in
    let w2 = halflen *' 0.3 in
    let t = fontsize *' 0.03 in
      (w0, w1, w2, t)


  val bracket-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x2, ytop)
        |> line-to (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x2, ybot)
        |> line-to (x2, ybot +' t)
        |> line-to (x1, ybot +' t)
        |> line-to (x1, ytop -' t)
        |> line-to (x2, ytop -' t)
        |> close-with-line


  val floor-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x2, ybot)
        |> line-to (x2, ybot +' t)
        |> line-to (x1, ybot +' t)
        |> line-to (x1, ytop)
        |> close-with-line


  val ceil-path x0 x1 x2 t ypos hgtaxis halflen =
    let ytop = ypos +' hgtaxis +' halflen in
    let ybot = ypos +' hgtaxis -' halflen in
      start-path (x2, ytop)
        |> line-to (x0, ytop)
        |> line-to (x0, ybot)
        |> line-to (x1, ybot)
        |> line-to (x1, ytop -' t)
        |> line-to (x2, ytop -' t)
        |> close-with-line


  val bracket-left pathf hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let (w0, w1, w2, t) = bracket-metrics fontsize halflen in
    let path (xpos, ypos) =
      let x0 = xpos +' w0 in
      let x1 = x0 +' w1 in
      let x2 = x1 +' w2 in
        pathf x0 x1 x2 t ypos hgtaxis halflen
    in
    let graphics point = [ fill color (path point), ] in
    let widparen = w0 +' w1 +' w2 in
      (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, (fun _ -> 0pt))


  val bracket-right pathf hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let (w0, w1, w2, t) = bracket-metrics fontsize halflen in
    let widparen = w0 +' w1 +' w2 in
    let path (xpos, ypos) =
      let x0 = xpos +' widparen -' w0 in
      let x1 = x0 -' w1 in
      let x2 = x1 -' w2 in
        pathf x0 x1 x2 t ypos hgtaxis halflen
    in
    let graphics point = [ fill color (path point), ] in
      (inline-graphics widparen (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, (fun _ -> 0pt))


  val sqbracket-left = bracket-left bracket-path
  val sqbracket-right = bracket-right bracket-path
  val math \sqbracket =
    math-paren sqbracket-left sqbracket-right


  val floor-left = bracket-left floor-path
  val floor-right = bracket-right floor-path
  val math \floor =
    math-paren floor-left floor-right


  val ceil-left = bracket-left ceil-path
  val ceil-right = bracket-right ceil-path
  val math \ceil =
    math-paren ceil-left ceil-right


  val empty-paren _ _ _ _ _ = (inline-nil, (fun _ -> 0pt))


  val abs-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 5.0pt in
    let path (xpos, ypos) =
      start-path (xpos +' wid *' 0.5, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid *' 0.5, ypos +' hgtaxis -' halflen)
        |> close-with-line
    in
    let graphics point = [ stroke 0.5pt color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val abs-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 5.0pt in
    let path (xpos, ypos) =
      start-path (xpos +' wid *' 0.5, ypos +' hgtaxis +' halflen)
        |> line-to (xpos +' wid *' 0.5, ypos +' hgtaxis -' halflen)
        |> close-with-line
    in
    let graphics point = [ stroke 0.5pt color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \abs =
    math-paren abs-left abs-right


  val norm-left hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 7.0pt in
    let path (xpos, ypos) =
      unite-path (
        start-path (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      ) (
        start-path (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      )
    in
    let graphics point = [ stroke 0.5pt color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val norm-right hgt dpt hgtaxis fontsize color =
    let halflen = half-length hgt dpt hgtaxis fontsize in
    let wid = 7.0pt in
    let path (xpos, ypos) =
      unite-path (
        start-path (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 -' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      ) (
        start-path (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis +' halflen)
          |> line-to (xpos +' wid *' 0.5 +' 1.2pt, ypos +' hgtaxis -' halflen)
          |> close-with-line
      )
    in
    let graphics point = [ stroke 0.5pt color (path point), ] in
    let kerninfo _ = 0pt in
      (inline-graphics wid (hgtaxis +' halflen) (halflen -' hgtaxis) graphics, kerninfo)


  val math \norm =
    math-paren norm-left norm-right


  val math \set m =
    ${\brace{#m}}


  val math \cases lst =
    let m-inner =
      text-in-math MathInner (fun ctx -> (
        let size = get-font-size ctx in
        let pads = (0pt, 0pt, size *' 0.25, size *' 0.25) in
        let celllstlst =
          lst |> List.map (fun (m, it) -> (
            let ib1 = embed-math ctx m ++ inline-fil in
            let ib2 = inline-skip size ++ read-inline ctx it ++ inline-fil in
              [NormalCell(pads, ib1), NormalCell(pads, ib2)]
          ))
        in
        let ib = tabular celllstlst (fun _ _ -> []) in
        let (_, hgt, dpt) = get-natural-metrics ib in
        let hgtaxis = get-axis-height ctx in
          raise-inline (hgtaxis -' (hgt +' dpt) *' 0.5) ib

      ))
    in
      math-paren brace-left empty-paren m-inner


end
