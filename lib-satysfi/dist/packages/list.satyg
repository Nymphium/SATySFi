@stage: persistent
@require: option

module List
% :> sig
%     val map : ('a -> 'b) -> 'a list -> 'b list
%     val mapi : (int -> 'a -> 'b) -> 'a list -> 'b list
%     val iter : ('a -> unit) -> 'a list -> unit
%     val iteri : (int -> 'a -> unit) -> 'a list -> unit
%     val fold-left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
%     val fold-lefti : (int -> 'a -> 'b -> 'a) -> 'a -> 'b list -> 'a
%     val fold-right : ('a -> 'b -> 'b) -> 'b -> 'a list -> 'b
%     val filter : ('a -> bool) -> 'a list -> 'a list
%     val assoc : ('a -> 'a -> bool) -> 'a -> ('a * 'b) list -> 'b option
%     val reverse : 'a list -> 'a list
%     val append : 'a list -> 'a list -> 'a list
%     val concat : ('a list) list -> 'a list
%     val fold-left-adjacent : ('a -> 'b -> 'b option -> 'b option -> 'a) -> 'a -> 'b list -> 'a
%     val map-adjacent : ('a -> 'a option -> 'a option -> 'b) -> 'a list -> 'b list
%     val mapi-adjacent : (int -> 'a -> 'a option -> 'a option -> 'b) -> 'a list -> 'b list
%     val length : 'a list -> int
%     val nth : int -> 'a list -> 'a option
%     val is-empty : 'a list -> bool
%     val map-with-ends : (bool -> bool -> 'a -> 'b) -> 'a list -> 'b list
%   end
= struct

    val rec map f ys =
      match ys with
      | []      -> []
      | x :: xs -> (f x) :: map f xs
      end


    val mapi f =
      let rec aux i f ys =
        match ys with
        | []      -> []
        | x :: xs -> (f i x) :: aux (i + 1) f xs
        end
      in
      aux 0 f


    val rec iter f ys =
      match ys with
      | []      -> ()
      | x :: xs -> let () = f x in iter f xs
      end


    val iteri f =
      let rec aux i f ys =
        match ys with
        | []      -> ()
        | x :: xs -> let () = f i x in aux (i + 1) f xs
        end
      in
      aux 0 f


    val rec fold-left f init ys =
      match ys with
      | []      -> init
      | x :: xs -> fold-left f (f init x) xs
      end


    val fold-lefti f =
      let rec aux i f init ys =
        match ys with
        | []      -> init
        | x :: xs -> aux (i + 1) f (f i init x) xs
        end
      in
      aux 0 f


    val rec fold-right f init ys =
      match ys with
      | []      -> init
      | x :: xs -> f x (fold-right f init xs)
      end


    val rec filter p ys =
      match ys with
      | []      -> []
      | x :: xs -> if p x then x :: filter p xs else filter p xs
      end


    val rec assoc eq a ys =
      match ys with
      | []           -> None
      | (x, y) :: xs -> if eq a x then Some(y) else assoc eq a xs
      end


    val reverse lst =
      fold-left (fun acc x -> x :: acc) [] lst


    val rec append lst1 lst2 =
      match lst1 with
      | []      -> lst2
      | x :: xs -> x :: append xs lst2
      end


    val concat lst = fold-right append [] lst


    val fold-left-adjacent f =
      let rec aux leftopt init lst =
        match lst with
        | [] ->
            init

        | head :: [] ->
            let initnew = f init head leftopt None in
            initnew

        | head :: ((right :: _) as tail) ->
            let initnew = f init head leftopt (Some(right)) in
            aux (Some(head)) initnew tail
        end
      in
      aux None


    val map-adjacent f lst =
        lst |> fold-left-adjacent (fun acc x leftopt rightopt -> (
          f x leftopt rightopt :: acc
        )) [] |> reverse


    val mapi-adjacent f lst =
      let (_, acc) =
        lst |> fold-left-adjacent (fun (i, acc) x leftopt rightopt -> (
          (i + 1, f i x leftopt rightopt :: acc)
        )) (0, [])
      in
        reverse acc


    val length lst =
      fold-right (fun _ i -> i + 1) 0 lst


    val nth lst =
      let rec aux i n xs =
        match xs with
        | []           -> None
        | head :: tail -> if n == i then Some(head) else aux (i + 1) n tail
        end
      in
      aux 0 lst


    val is-empty xs =
      match xs with
      | []     -> true
      | _ :: _ -> false
      end


    val map-with-ends f xs =
      fold-left-adjacent (fun acc x prev next -> (
        let is-first = Option.is-none prev in
        let is-last = Option.is-none next in
        let y = f is-first is-last x in
        y :: acc
      )) [] xs |> reverse

  end
